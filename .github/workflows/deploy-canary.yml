name: Deploy Canary

on:
  push:
    branches:
      - main
      - deploy
  workflow_dispatch:

env:
  IMAGE_NAME: ghcr.io/karan-wakade/smu
  KUBERNETES_NAMESPACE: default

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=short
            type=ref,event=branch

      - name: Build and push image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-canary:
    needs: build-and-push
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v3

      - name: Set Kubernetes Context
        shell: powershell
        run: |
          $configPath = "$PWD\.github\kubeconfig\config"
          $env:KUBECONFIG = $configPath
          kubectl cluster-info

      - name: Setup Argo Rollouts CLI Path
        shell: powershell
        run: |
          # Define path to the manually installed binary
          # This should be on the runner machine, NOT in the git repo
          $cliPath = "C:\tools\kubectl-argo-rollouts.exe"

          # Check if it exists, if not create directory and copy from a network location
          if (-not (Test-Path $cliPath)) {
              Write-Host "CLI not found, creating directory and installing..."
              $toolsDir = "C:\tools"
              if (-not (Test-Path $toolsDir)) {
                  New-Item -ItemType Directory -Force -Path $toolsDir | Out-Null
              }
              
              # Option 1: Copy from network share if available
              # Copy-Item "\\networkshare\tools\kubectl-argo-rollouts.exe" -Destination $cliPath
              
              # Option 2: Output error and instructions
              Write-Host "ERROR: kubectl-argo-rollouts.exe not found at $cliPath"
              Write-Host "Please manually install it using these steps:"
              Write-Host "1. Download kubectl-argo-rollouts-windows-amd64.exe from https://github.com/argoproj/argo-rollouts/releases/latest/"
              Write-Host "2. Rename it to kubectl-argo-rollouts.exe"
              Write-Host "3. Place it at $cliPath"
              exit 1
          }

          # Add the directory to PATH for this workflow run
          $binDir = [System.IO.Path]::GetDirectoryName($cliPath)
          echo "$binDir" | Out-File -FilePath $env:GITHUB_PATH -Append
          $env:PATH = "$binDir;$env:PATH"

          # Test the CLI
          & $cliPath version

      - name: Set up Kubeconfig
        shell: powershell
        run: |
          # Create .kube directory if it doesn't exist
          $kubeDir = "$env:USERPROFILE\.kube"
          if (-not (Test-Path $kubeDir)) {
              New-Item -ItemType Directory -Force -Path $kubeDir | Out-Null
          }

          # Set the kubeconfig content from GitHub secret
          $kubeconfig = @'
          ${{ secrets.KUBECONFIG }}
          '@

          # Write to file
          $kubeconfig | Out-File -FilePath "$kubeDir\config" -Encoding utf8 -Force

          # Verify kubectl can connect to the cluster
          kubectl cluster-info

          # Set environment variable for subsequent steps
          echo "KUBECONFIG=$kubeDir\config" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Diagnose Rollout Issues
        shell: powershell
        run: |
          # Print current namespace
          Write-Host "Current namespace: $(kubectl config view --minify -o jsonpath='{..namespace}')"

          # List all namespaces to find where rollouts exist
          Write-Host "All namespaces in the cluster:"
          kubectl get namespaces

          # Check if Argo Rollouts CRD is installed
          Write-Host "Checking if Argo Rollouts CRD is installed:"
          kubectl get crd | findstr rollouts

          # List rollouts across all namespaces
          Write-Host "All rollouts in the cluster:"
          kubectl get rollouts --all-namespaces

          # List all resources in the target namespace - FIXED LINE
          $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
          Write-Host "All resources in namespace $($namespace):"   # Use $() for variable expansion
          kubectl get all -n $namespace

          # Show environment variables for debugging
          Write-Host "Environment variables:"
          Get-ChildItem Env: | Format-Table -AutoSize

      - name: Check Argo Rollouts Status
        shell: powershell
        id: rollouts-check
        continue-on-error: true
        run: |
          # Check if Argo Rollouts controller is running
          Write-Host "Checking Argo Rollouts controller status..."
          $controllerPods = kubectl get pods -n argo-rollouts -l app.kubernetes.io/component=rollouts-controller -o jsonpath='{.items[*].status.phase}' --ignore-not-found

          if ($controllerPods -match "Running") {
            Write-Host "Argo Rollouts controller is running."
            echo "USE_STANDARD_DEPLOYMENT=false" | Out-File -FilePath $env:GITHUB_ENV -Append
          } else {
            Write-Host "Argo Rollouts controller not found or not running. Will use standard deployments."
            echo "USE_STANDARD_DEPLOYMENT=true" | Out-File -FilePath $env:GITHUB_ENV -Append
          }

      - name: Convert to Standard Deployment
        if: env.USE_STANDARD_DEPLOYMENT == 'true'
        shell: powershell
        run: |
          # Settings
          $overlay = if ("${{ github.ref_name }}" -eq "main") { "production" } else { "staging" }          Write-Host "Using overlay: $overlay"

          # Convert rollout.yaml to deployment.yaml
          Write-Host "Converting rollout.yaml to standard deployment.yaml..."
          $rolloutContent = Get-Content -Path "kubernetes/overlays/$($overlay)/rollout.yaml" -Raw

          # Replace Rollout specific parts with Deployment
          $deploymentContent = $rolloutContent -replace "apiVersion: argoproj.io/v1alpha1", "apiVersion: apps/v1" `
                                              -replace "kind: Rollout", "kind: Deployment"

          # Remove the strategy section that's specific to Argo Rollouts
          if ($deploymentContent -match "(?s)(\s+strategy:\s+canary:.*?)(\s+selector:|\s+template:)") {
            $deploymentContent = $deploymentContent -replace "(?s)(\s+strategy:\s+canary:.*?)(\s+selector:|\s+template:)", "$2"
          }

          # Add a standard deployment strategy
          if ($deploymentContent -match "(?s)(\s+selector:)") {
            $deploymentContent = $deploymentContent -replace "(?s)(\s+selector:)", "  strategy:`n    type: RollingUpdate`n    rollingUpdate:`n      maxSurge: 1`n      maxUnavailable: 0`n$1"
          }

          # Save the deployment file
          $deploymentContent | Out-File -FilePath "kubernetes/overlays/$($overlay)/deployment.yaml" -Encoding utf8

          # Update kustomization.yaml to use deployment instead of rollout
          $kustomizationContent = @"
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization

          resources:
          - deployment.yaml

          namespace: ${{ env.KUBERNETES_NAMESPACE }}

          labels:
          - pairs:
              app: smu
              environment: $overlay
          "@
          $kustomizationContent | Out-File -FilePath "kubernetes/overlays/$($overlay)/kustomization.yaml" -Encoding utf8

          Write-Host "Converted to standard Kubernetes deployment"

      - name: Deploy and Update
        shell: powershell
        run: |
          # Settings
          $overlay = if ("${{ github.ref_name }}" -eq "main") { "production" } else { "staging" }          Write-Host "Using overlay: $overlay"
          $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
          $useStandardDeployment = "${{ env.USE_STANDARD_DEPLOYMENT }}" -eq "true"
          $resourceName = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }          $resourceType = $useStandardDeployment ? "deployment" : "rollout"

          # Apply with retries
          cd "kubernetes/overlays/$overlay"
          Write-Host "Applying Kubernetes resources ($resourceType)..."

          $maxAttempts = 3
          $success = $false

          for ($attempt = 1; $attempt -le $maxAttempts; $attempt++) {
            Write-Host "Attempt $attempt of $maxAttempts"
            
            try {
              kubectl apply -k . --timeout=30s
              $success = $true
              break
            } catch {
              Write-Host "Error applying resources: $_"
              if ($attempt -lt $maxAttempts) {
                Write-Host "Waiting 5 seconds before retry..."
                Start-Sleep -Seconds 5
              }
            }
          }

          if (-not $success) {
            Write-Host "ERROR: Failed to apply resources after $maxAttempts attempts!"
            exit 1
          }

          # Update the image based on deployment type
          Write-Host "Updating container image for $resourceType/$resourceName..."

          if ($useStandardDeployment) {
            # Standard kubectl approach for Deployments
            kubectl set image deployment/$resourceName smu-container=${{ env.IMAGE_NAME }}:${{ github.sha }} -n $namespace
            
            # Watch rollout status for Deployment
            Write-Host "Watching deployment rollout status..."
            kubectl rollout status deployment/$resourceName -n $namespace --timeout=2m
          } else {
            # Argo Rollouts approach
            kubectl argo rollouts set image $resourceName smu-container=${{ env.IMAGE_NAME }}:${{ github.sha }} -n $namespace
            
            # Try to watch status, but continue even if it fails
            try {
              Write-Host "Watching Argo Rollouts status..."
              kubectl argo rollouts status $resourceName -n $namespace --timeout=30s
            } catch {
              Write-Host "Warning: Couldn't watch rollout status: $_"
              Write-Host "Argo Rollouts status command timed out, but the update might still be in progress."
              Write-Host "You can check the status later manually."
            }
          }

          Write-Host "Deployment completed successfully!"

      # - name: Deploy Kubernetes Resources
      #   shell: powershell
      #   run: |
      #     # Determine which overlay to use based on branch
      #     $overlay = if ("${{ github.ref_name }}" -eq "main") { "production" } else { "staging" }          Write-Host "Using overlay: $overlay"
      #     Write-Host "Using overlay: $overlay"

      #     # Update kustomization.yaml to use 'labels' instead of 'commonLabels'
      #     $kustomizationPath = "kubernetes/overlays/$overlay/kustomization.yaml"
      #     $kustomizationContent = @"
      #     apiVersion: kustomize.config.k8s.io/v1beta1
      #     kind: Kustomization

      #     resources:
      #     - rollout.yaml

      #     namespace: ${{ env.KUBERNETES_NAMESPACE }}

      #     labels:
      #     - pairs:
      #         app: smu
      #         environment: $overlay
      #     "@
      #     $kustomizationContent | Out-File -FilePath $kustomizationPath -Encoding utf8

      #     # List files to verify
      #     Write-Host "Files in kubernetes/overlays/$($overlay):"
      #     Get-ChildItem -Path "kubernetes/overlays/$overlay" -Recurse

      #     # Apply the configuration
      #     cd "kubernetes/overlays/$overlay"
      #     kubectl apply -k .

      #     # Wait for rollout to be ready - FIXED COMMAND
      #     $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
      #     $rolloutName = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }

      #     Write-Host "Waiting for rollout '$($rolloutName)' in namespace '$($namespace)' to be ready..."
      #     try {
      #       # Use the full resource type for Argo Rollouts
      #       kubectl wait --for=condition=Progressing "rollouts.argoproj.io/$rolloutName" -n $namespace --timeout=30s
      #       Write-Host "Rollout '$rolloutName' is ready"
      #     } catch {
      #       Write-Host "WARNING: Rollout not ready in time or error occurred:"
      #       Write-Host $_
      #       # Continue anyway since the rollout was created
      #     }

      # - name: Update Rollout Image
      #   shell: powershell
      #   run: |
      #     # Get the new image tag
      #     $IMAGE_TAG = "${{ github.sha }}"
      #     $SHORT_SHA = $IMAGE_TAG.Substring(0, 7)
      #     $FULL_IMAGE = "${{ env.IMAGE_NAME }}:sha-$SHORT_SHA"

      #     # Update the rollout with the new image
      #     $ROLLOUT_NAME = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }
      #     kubectl argo rollouts set image $ROLLOUT_NAME smu=$FULL_IMAGE -n ${{ env.KUBERNETES_NAMESPACE }}

      - name: Watch Rollout
        shell: powershell
        run: |
          $ROLLOUT_NAME = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }
          kubectl argo rollouts get rollout $ROLLOUT_NAME -n ${{ env.KUBERNETES_NAMESPACE }}

          # Monitor status with timeout instead of watching indefinitely
          $timeout = 300  # 5 minutes
          $startTime = Get-Date
          $status = ""

          while ((Get-Date).Subtract($startTime).TotalSeconds -lt $timeout) {
            $status = kubectl argo rollouts status $ROLLOUT_NAME -n ${{ env.KUBERNETES_NAMESPACE }}
            if ($status -match "successfully") {
              Write-Host "Rollout completed successfully!"
              exit 0
            }
            Start-Sleep -Seconds 10
          }

          Write-Error "Rollout did not complete within timeout period"
          exit 1

      - name: Promote Rollout (if needed)
        if: github.ref_name == 'main'
        shell: powershell
        run: |
          try {
            kubectl argo rollouts promote production-rollout -n ${{ env.KUBERNETES_NAMESPACE }}
            Write-Host "Promotion successful!"
          } catch {
            Write-Error "Failed to promote rollout: $_"
            exit 1
          }
