name: Deploy Canary

on:
  push:
    branches:
      - main
      - deploy
  workflow_dispatch:

env:
  IMAGE_NAME: ghcr.io/karan-wakade/smu
  KUBERNETES_NAMESPACE: default

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=short
            type=ref,event=branch

      - name: Build and push image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-canary:
    needs: build-and-push
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v3

      - name: Set Kubernetes Context
        shell: powershell
        run: |
          $configPath = "$PWD\.github\kubeconfig\config"
          $env:KUBECONFIG = $configPath
          kubectl cluster-info

      - name: Install Argo Rollouts CLI
        shell: powershell
        run: |
          # Enable TLS 1.2 (often required for modern HTTPS connections)
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

          # Set variables
          $binDir = "$env:USERPROFILE\bin"
          $cliName = "kubectl-argo-rollouts.exe"
          $cliPath = "$binDir\$cliName"
          $url = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-windows-amd64.exe"

          # Create bin directory if needed
          if (-not (Test-Path $binDir)) {
              New-Item -ItemType Directory -Force -Path $binDir | Out-Null
              Write-Host "Created directory: $binDir"
          }

          # Try multiple download methods
          Write-Host "Downloading Argo Rollouts CLI from $url"

          $downloadSuccess = $false

          # Method 1: Invoke-WebRequest with exception handling
          try {
              Invoke-WebRequest -Uri $url -OutFile $cliPath -UseBasicParsing -TimeoutSec 60
              if (Test-Path $cliPath) {
                  $downloadSuccess = $true
                  Write-Host "Download successful using Invoke-WebRequest"
              }
          }
          catch {
              Write-Host "Invoke-WebRequest failed: $_"
          }

          # Method 2: Try with .NET WebClient if Method 1 failed
          if (-not $downloadSuccess) {
              try {
                  Write-Host "Trying alternative download method with WebClient..."
                  $webClient = New-Object System.Net.WebClient
                  $webClient.DownloadFile($url, $cliPath)
                  
                  if (Test-Path $cliPath) {
                      $downloadSuccess = $true
                      Write-Host "Download successful using WebClient"
                  }
              }
              catch {
                  Write-Host "WebClient download failed: $_"
              }
          }

          # Method 3: Try with System.Net.Http.HttpClient
          if (-not $downloadSuccess) {
              try {
                  Write-Host "Trying download with HttpClient..."
                  Add-Type -AssemblyName System.Net.Http
                  $client = New-Object System.Net.Http.HttpClient
                  $response = $client.GetAsync($url).Result
                  $response.EnsureSuccessStatusCode()
                  $fileStream = [System.IO.File]::Create($cliPath)
                  $response.Content.CopyToAsync($fileStream).Wait()
                  $fileStream.Close()
                  
                  if (Test-Path $cliPath) {
                      $downloadSuccess = $true
                      Write-Host "Download successful using HttpClient"
                  }
              }
              catch {
                  Write-Host "HttpClient download failed: $_"
              }
          }

          # Method 4: Try with BITS Transfer (Windows-specific)
          if (-not $downloadSuccess) {
              try {
                  Write-Host "Trying download with BITS Transfer..."
                  Start-BitsTransfer -Source $url -Destination $cliPath
                  
                  if (Test-Path $cliPath) {
                      $downloadSuccess = $true
                      Write-Host "Download successful using BITS Transfer"
                  }
              }
              catch {
                  Write-Host "BITS Transfer download failed: $_"
              }
          }

          # Verify download success
          if (-not $downloadSuccess) {
              Write-Host "All download methods failed. Cannot install Argo Rollouts CLI."
              exit 1
          }

          # Add to PATH
          Write-Host "Adding $binDir to PATH"
          echo "$binDir" | Out-File -FilePath $env:GITHUB_PATH -Append
          $env:PATH = "$binDir;$env:PATH"

          # Verify installation
          try {
              & $cliPath version
              Write-Host "Argo Rollouts CLI installed successfully!"
          }
          catch {
              Write-Host "Warning: CLI installed but verification failed: $_"
              Write-Host "Continuing workflow..."
          }

      # - name: Install Argo Rollouts CLI
      #   shell: powershell
      #   run: |
      #     Write-Host "Downloading Argo Rollouts CLI using curl..."
      #     curl.exe -L -o kubectl-argo-rollouts.exe https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-windows-amd64.exe

      #     # Add to PATH for this session
      #     $env:PATH = "$PWD;$env:PATH"

      #     # Verify installation
      #     ./kubectl-argo-rollouts.exe version

      - name: Update Rollout Image
        shell: powershell
        run: |
          # Get the new image tag
          $IMAGE_TAG = "${{ github.sha }}"
          $SHORT_SHA = $IMAGE_TAG.Substring(0, 7)
          $FULL_IMAGE = "${{ env.IMAGE_NAME }}:sha-$SHORT_SHA"

          # Update the rollout with the new image
          $ROLLOUT_NAME = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }
          kubectl argo rollouts set image $ROLLOUT_NAME smu=$FULL_IMAGE -n ${{ env.KUBERNETES_NAMESPACE }}

      # - name: Update Rollout Image
      #   run: |
      #     # Get the new image tag
      #     $IMAGE_TAG="${{ github.sha }}"
      #     $SHORT_SHA="${IMAGE_TAG:0:7}"
      #     $FULL_IMAGE="${{ env.IMAGE_NAME }}:sha-$SHORT_SHA"

      #     # Update the rollout with the new image
      #     kubectl argo rollouts set image ${{ github.ref_name == 'main' ? 'production' : 'staging' }}-rollout smu=$FULL_IMAGE -n ${{ env.KUBERNETES_NAMESPACE }}

      - name: Watch Rollout
        shell: powershell
        run: |
          $ROLLOUT_NAME = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }
          kubectl argo rollouts get rollout $ROLLOUT_NAME -n ${{ env.KUBERNETES_NAMESPACE }}

          # Monitor status with timeout instead of watching indefinitely
          $timeout = 300  # 5 minutes
          $startTime = Get-Date
          $status = ""

          while ((Get-Date).Subtract($startTime).TotalSeconds -lt $timeout) {
            $status = kubectl argo rollouts status $ROLLOUT_NAME -n ${{ env.KUBERNETES_NAMESPACE }}
            if ($status -match "successfully") {
              Write-Host "Rollout completed successfully!"
              exit 0
            }
            Start-Sleep -Seconds 10
          }

          Write-Error "Rollout did not complete within timeout period"
          exit 1

      # - name: Watch Rollout
      #   run: |
      #     kubectl argo rollouts get rollout ${{ github.ref_name == 'main' ? 'production' : 'staging' }}-rollout -n ${{ env.KUBERNETES_NAMESPACE }} -w

      - name: Promote Rollout (if needed)
        if: github.ref_name == 'main'
        shell: powershell
        run: |
          try {
            kubectl argo rollouts promote production-rollout -n ${{ env.KUBERNETES_NAMESPACE }}
            Write-Host "Promotion successful!"
          } catch {
            Write-Error "Failed to promote rollout: $_"
            exit 1
          }

      # - name: Promote Rollout (if needed)
      #   if: github.ref_name == 'main'
      #   run: |
      #     kubectl argo rollouts promote ${{ github.ref_name == 'main' ? 'production' : 'staging' }}-rollout -n ${{ env.KUBERNETES_NAMESPACE }}
