name: Deploy Canary

on:
  push:
    branches:
      - main
      - deploy
  workflow_dispatch:

env:
  IMAGE_NAME: ghcr.io/karan-wakade/smu
  KUBERNETES_NAMESPACE: default

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=sha,format=short
            type=ref,event=branch

      - name: Build and push image
        uses: docker/build-push-action@v4
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-canary:
    needs: build-and-push
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v3

      - name: Set Kubernetes Context
        shell: powershell
        run: |
          $configPath = "$PWD\.github\kubeconfig\config"
          $env:KUBECONFIG = $configPath
          kubectl cluster-info

      - name: Setup Argo Rollouts CLI Path
        shell: powershell
        run: |
          # Define path to the manually installed binary
          # This should be on the runner machine, NOT in the git repo
          $cliPath = "C:\tools\kubectl-argo-rollouts.exe"

          # Check if it exists, if not create directory and copy from a network location
          if (-not (Test-Path $cliPath)) {
              Write-Host "CLI not found, creating directory and installing..."
              $toolsDir = "C:\tools"
              if (-not (Test-Path $toolsDir)) {
                  New-Item -ItemType Directory -Force -Path $toolsDir | Out-Null
              }
              
              # Option 1: Copy from network share if available
              # Copy-Item "\\networkshare\tools\kubectl-argo-rollouts.exe" -Destination $cliPath
              
              # Option 2: Output error and instructions
              Write-Host "ERROR: kubectl-argo-rollouts.exe not found at $cliPath"
              Write-Host "Please manually install it using these steps:"
              Write-Host "1. Download kubectl-argo-rollouts-windows-amd64.exe from https://github.com/argoproj/argo-rollouts/releases/latest/"
              Write-Host "2. Rename it to kubectl-argo-rollouts.exe"
              Write-Host "3. Place it at $cliPath"
              exit 1
          }

          # Add the directory to PATH for this workflow run
          $binDir = [System.IO.Path]::GetDirectoryName($cliPath)
          echo "$binDir" | Out-File -FilePath $env:GITHUB_PATH -Append
          $env:PATH = "$binDir;$env:PATH"

          # Test the CLI
          & $cliPath version

      # - name: Install Argo Rollouts CLI
      #   shell: powershell
      #   run: |
      #     Write-Host "Downloading Argo Rollouts CLI using curl..."
      #     curl.exe -L -o kubectl-argo-rollouts.exe https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-windows-amd64.exe

      #     # Add to PATH for this session
      #     $env:PATH = "$PWD;$env:PATH"

      #     # Verify installation
      #     ./kubectl-argo-rollouts.exe version

      - name: Set up Kubeconfig
        shell: powershell
        run: |
          # Create .kube directory if it doesn't exist
          $kubeDir = "$env:USERPROFILE\.kube"
          if (-not (Test-Path $kubeDir)) {
              New-Item -ItemType Directory -Force -Path $kubeDir | Out-Null
          }

          # Set the kubeconfig content from GitHub secret
          $kubeconfig = @'
          ${{ secrets.KUBECONFIG }}
          '@

          # Write to file
          $kubeconfig | Out-File -FilePath "$kubeDir\config" -Encoding utf8 -Force

          # Verify kubectl can connect to the cluster
          kubectl cluster-info

          # Set environment variable for subsequent steps
          echo "KUBECONFIG=$kubeDir\config" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Diagnose Rollout Issues
        shell: powershell
        run: |
          # Print current namespace
          Write-Host "Current namespace: $(kubectl config view --minify -o jsonpath='{..namespace}')"

          # List all namespaces to find where rollouts exist
          Write-Host "All namespaces in the cluster:"
          kubectl get namespaces

          # Check if Argo Rollouts CRD is installed
          Write-Host "Checking if Argo Rollouts CRD is installed:"
          kubectl get crd | findstr rollouts

          # List rollouts across all namespaces
          Write-Host "All rollouts in the cluster:"
          kubectl get rollouts --all-namespaces

          # List all resources in the target namespace - FIXED LINE
          $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
          Write-Host "All resources in namespace $($namespace):"   # Use $() for variable expansion
          kubectl get all -n $namespace

          # Show environment variables for debugging
          Write-Host "Environment variables:"
          Get-ChildItem Env: | Format-Table -AutoSize

      - name: Deploy Kubernetes Resources
        shell: powershell
        run: |
          # Determine which overlay to use based on branch
          $overlay = if ("${{ github.ref_name }}" -eq "main") { "production" } else { "staging" }          Write-Host "Using overlay: $overlay"
          Write-Host "Using overlay: $overlay"

          # Update kustomization.yaml to use 'labels' instead of 'commonLabels'
          $kustomizationPath = "kubernetes/overlays/$overlay/kustomization.yaml"
          $kustomizationContent = @"
          apiVersion: kustomize.config.k8s.io/v1beta1
          kind: Kustomization

          resources:
          - rollout.yaml

          namespace: ${{ env.KUBERNETES_NAMESPACE }}

          labels:
          - pairs:
              app: smu
              environment: $overlay
          "@
          $kustomizationContent | Out-File -FilePath $kustomizationPath -Encoding utf8

          # List files to verify
          Write-Host "Files in kubernetes/overlays/$($overlay):"
          Get-ChildItem -Path "kubernetes/overlays/$overlay" -Recurse

          # Apply the configuration
          cd "kubernetes/overlays/$overlay"
          kubectl apply -k .

          # Wait for rollout to be ready - FIXED COMMAND
          $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
          $rolloutName = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }

          Write-Host "Waiting for rollout '$($rolloutName)' in namespace '$($namespace)' to be ready..."
          try {
            # Use the full resource type for Argo Rollouts
            kubectl wait --for=condition=Progressing "rollouts.argoproj.io/$rolloutName" -n $namespace --timeout=30s
            Write-Host "Rollout '$rolloutName' is ready"
          } catch {
            Write-Host "WARNING: Rollout not ready in time or error occurred:"
            Write-Host $_
            # Continue anyway since the rollout was created
          }

      # - name: Deploy Kubernetes Resources
      #   shell: powershell
      #   run: |
      #     # Determine which overlay to use based on branch
      #     $overlay = if ("${{ github.ref_name }}" -eq "main") { "production" } else { "staging" }          Write-Host "Using overlay: $overlay"

      #     # Apply Kustomize configuration
      #     cd kubernetes/overlays/$overlay

      #     # List files to verify
      #     # Write-Host "Files in kubernetes/overlays/$overlay:"
      #     Get-ChildItem -Recurse

      #     # Apply the configuration
      #     kubectl apply -k .

      #     # Wait for rollout to be ready
      #     $namespace = "${{ env.KUBERNETES_NAMESPACE }}"
      #     $ROLLOUT_NAME = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }
      #     Write-Host "Waiting for rollout $rolloutName in namespace $namespace to be ready..."
      #     try {
      #       kubectl wait --for=condition=Progressing rollout/$rolloutName -n $namespace --timeout=30s
      #       Write-Host "Rollout is ready"
      #     } catch {
      #       Write-Host "WARNING: Rollout not ready in time. Will attempt to proceed anyway."
      #     }

      - name: Update Rollout Image
        shell: powershell
        run: |
          # Get the new image tag
          $IMAGE_TAG = "${{ github.sha }}"
          $SHORT_SHA = $IMAGE_TAG.Substring(0, 7)
          $FULL_IMAGE = "${{ env.IMAGE_NAME }}:sha-$SHORT_SHA"

          # Update the rollout with the new image
          $ROLLOUT_NAME = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }
          kubectl argo rollouts set image $ROLLOUT_NAME smu=$FULL_IMAGE -n ${{ env.KUBERNETES_NAMESPACE }}

      # - name: Update Rollout Image
      #   run: |
      #     # Get the new image tag
      #     $IMAGE_TAG="${{ github.sha }}"
      #     $SHORT_SHA="${IMAGE_TAG:0:7}"
      #     $FULL_IMAGE="${{ env.IMAGE_NAME }}:sha-$SHORT_SHA"

      #     # Update the rollout with the new image
      #     kubectl argo rollouts set image ${{ github.ref_name == 'main' ? 'production' : 'staging' }}-rollout smu=$FULL_IMAGE -n ${{ env.KUBERNETES_NAMESPACE }}

      - name: Watch Rollout
        shell: powershell
        run: |
          $ROLLOUT_NAME = if ("${{ github.ref_name }}" -eq "main") { "production-rollout" } else { "staging-rollout" }
          kubectl argo rollouts get rollout $ROLLOUT_NAME -n ${{ env.KUBERNETES_NAMESPACE }}

          # Monitor status with timeout instead of watching indefinitely
          $timeout = 300  # 5 minutes
          $startTime = Get-Date
          $status = ""

          while ((Get-Date).Subtract($startTime).TotalSeconds -lt $timeout) {
            $status = kubectl argo rollouts status $ROLLOUT_NAME -n ${{ env.KUBERNETES_NAMESPACE }}
            if ($status -match "successfully") {
              Write-Host "Rollout completed successfully!"
              exit 0
            }
            Start-Sleep -Seconds 10
          }

          Write-Error "Rollout did not complete within timeout period"
          exit 1

      # - name: Watch Rollout
      #   run: |
      #     kubectl argo rollouts get rollout ${{ github.ref_name == 'main' ? 'production' : 'staging' }}-rollout -n ${{ env.KUBERNETES_NAMESPACE }} -w

      - name: Promote Rollout (if needed)
        if: github.ref_name == 'main'
        shell: powershell
        run: |
          try {
            kubectl argo rollouts promote production-rollout -n ${{ env.KUBERNETES_NAMESPACE }}
            Write-Host "Promotion successful!"
          } catch {
            Write-Error "Failed to promote rollout: $_"
            exit 1
          }

      # - name: Promote Rollout (if needed)
      #   if: github.ref_name == 'main'
      #   run: |
      #     kubectl argo rollouts promote ${{ github.ref_name == 'main' ? 'production' : 'staging' }}-rollout -n ${{ env.KUBERNETES_NAMESPACE }}
